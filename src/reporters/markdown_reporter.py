import os
from datetime import datetime
from pathlib import Path
from typing import List, Dict
import aiofiles
from .base_reporter import BaseReporter
from ..models.vulnerability import Vulnerability, Severity

class MarkdownReporter(BaseReporter):
    """Markdown implementation of the vulnerability reporter."""
    
    async def report(self, vulnerabilities: List[Vulnerability]) -> None:
        """Generate and save a markdown report of the vulnerabilities found."""
        report_sections = [
            self._generate_header(),
            await self.get_summary(vulnerabilities),
            "",
            "## Detailed Findings",
            "",
            *[self._format_vulnerability(v) for v in vulnerabilities]
        ]
        
        output_file = self.config.output_dir / f"sast_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        async with aiofiles.open(output_file, mode='w', encoding='utf-8') as f:
            await f.write("\n".join(report_sections))
            
    async def get_summary(self, vulnerabilities: List[Vulnerability]) -> str:
        """Get a markdown summary of the vulnerabilities found."""
        severity_counts = {severity: 0 for severity in Severity}
        for vuln in vulnerabilities:
            severity_counts[vuln.severity] += 1
            
        summary_lines = [
            "## Summary",
            "",
            f"Scan completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Target directory: `{self.config.target_dir}`",
            f"Total vulnerabilities found: {len(vulnerabilities)}",
            "",
            "### Severity Breakdown",
            "",
            *[f"- **{severity.value}**: {count}" for severity, count in severity_counts.items() if count > 0],
            ""
        ]
        
        return "\n".join(summary_lines)
        
    def _generate_header(self) -> str:
        """Generate the markdown report header."""
        return "\n".join([
            "# Security Analysis Report",
            "",
            "> This report was automatically generated by the LLM-powered SAST Scanner",
            "",
        ])
        
    def _format_vulnerability(self, vuln: Vulnerability) -> str:
        """Format a single vulnerability as markdown."""
        sections = [
            f"### {vuln.title}",
            "",
            f"**Severity**: {vuln.severity.value}",
            f"**CWE**: [{vuln.cwe_id}]({vuln.cwe_url})" if vuln.cwe_id else "",
            "",
            "#### Description",
            "",
            vuln.description,
            "",
            "#### Affected Code",
            "",
            f"File: `{vuln.location.file_path}`",
            f"Lines: {vuln.location.start_line}-{vuln.location.end_line}",
            "```",
            vuln.location.snippet,
            "```",
            ""
        ]
        
        if vuln.proof_of_concept:
            sections.extend([
                "#### Proof of Concept",
                "",
                "> This section demonstrates how this vulnerability could be exploited.",
                "",
                vuln.proof_of_concept,
                ""
            ])
            
        if vuln.fix:
            sections.extend([
                "#### How to Fix",
                "",
                "> This section provides detailed instructions for fixing this vulnerability.",
                "",
                vuln.fix,
                ""
            ])
            
        if vuln.recommendation:
            sections.extend([
                "#### Additional Security Recommendations",
                "",
                vuln.recommendation,
                "",
                "---",
                ""
            ])
            
        return "\n".join(filter(None, sections)) 